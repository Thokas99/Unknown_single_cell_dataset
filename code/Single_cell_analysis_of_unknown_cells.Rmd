---
title: "Single cell RNA-Seq analysis of Unknown cells"
output: html_notebook
---

#### Load the necessary packages to perform the analysis

```{r load_packages,warning=F,message=F}

library(tidyverse) # collection of packages for tidy data analysis 
library(Seurat) # single cell analysis
library(patchwork) # combine separate ggplots into the same graphic
library(SingleR)

```

## Analysis of Unknown cells

### Reading in the data. 

```{r load_data,warning=F,message=F}

#filename <- file.choose()
pbmc_mat <- readRDS("./data/XUR.rds") 

```

### Initialize the Seurat object with the digital count matrix
Use the count matrix to create a Seurat object. The object serves as a container that contains both data (like the count matrix) and analysis (like PCA, or clustering results) for a single-cell dataset. 
Seurat v5 assays store data in layers. These layers can store raw, un-normalized counts (layer='counts'), normalized data (layer='data'), or z-scored/variance-stabilized data (layer='scale.data').


```{r create_seurat, warning=F, message=F}

pbmc <- CreateSeuratObject(counts = pbmc_mat, 
                           project = "pbmc", # name of the project
                           min.cells = 3,   # filter for genes (rows)
                           min.features = 50 # filter for cells (columns)
                           )
pbmc

```
Access the count matrix and check teh data
```{r}
pbmc[["RNA"]]$counts[500:505, 1:30]
LayerData(pbmc, assay = "RNA", layer = "counts")[500:505, 1:30]

```
## Standard workflow

### QC and selecting cells for further analysis

A few QC metrics commonly used by the community include:

1- The number of unique genes detected in each cell (low-quality cells or empty droplets will often have very few genes, while cell doublets or multiplets may exhibit an aberrantly high gene count)

2- The total number of molecules detected within a cell (correlates strongly with unique genes)

3- The percentage of reads that map to the mitochondrial genome (low-quality or dying cells often exhibit extensive mitochondrial contamination)

The PercentageFeatureSet function calculates the percentage of counts originating from a set of features (for example, you can use the set of all genes starting with MT- as a set of mitochondrial genes).

The number of unique genes (nFeature_RNA) and total molecules (nCount_RNA) are automatically calculated during CreateSeuratObject. You can find them stored in the object meta data.

```{r qc_metrics, warning=F, message=F}

# The [[ operator can add columns to the object meta.data, ideal to stash QC stats
pbmc[["percent_ERCC"]] <- PercentageFeatureSet(pbmc, pattern = "^ERCC-")

# Show QC metrics for the first 5 cells
head(pbmc@meta.data, 5)

```


#### Visualize QC metrics as a violin plot

```{r qc_violin, warning=F, message=F}

p1<- VlnPlot(pbmc, features = c("nFeature_RNA", "nCount_RNA", "percent_ERCC"), ncol = 3, pt.size = 0.01)

p1

```


#### FeatureScatter is typically used to visualize feature-feature relationships, but can be used for anything calculated by the object, i.e. columns in object metadata, PC scores etc.

```{r qc_scatter, warning=F, message=F}

plot1 <- FeatureScatter(pbmc, feature1 = "nCount_RNA", feature2 = "percent_ERCC")
plot2 <- FeatureScatter(pbmc, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2
```

#### Filter cells based on QC values (nFeature and percent_ERCC)

```{r qc_filter, warning=F, message=F}

pbmc <- subset(pbmc, subset = nFeature_RNA > 1500 & 
                  nFeature_RNA < 6000 & 
                  percent_ERCC < 80)
pbmc

```

### Normalize data

After removing unwanted cells from the dataset, the next step is to normalize the data.

By default, Seurat employs a global-scaling normalization method "LogNormalize" that normalizes the feature expression measurements for each cell by the total expression, multiplies this by a scale factor (10,000 by default)(to reduce technical variation from sequencing depth), and log-transforms the result (to reduce skewness). Normalized values are stored in the data layer (pbmc[["RNA"]]$data).

Questionable assumption: each cell should have the same number of reads.

Alternative normalization methods are also available (e.g. sctransform)

```{r normalization, warning=F, message=F}

pbmc <- NormalizeData(pbmc, 
                      normalization.method = "LogNormalize", 
                      scale.factor = 10000)

pbmc[["RNA"]]$data[1:10,1:30]

```


### Identification of highly variable features (feature selection)

We next select a subset of features (genes) that exhibit high cell-to-cell variation in the dataset (i.e, they are highly expressed in some cells, and lowly expressed in others). Focusing on these genes in downstream analysis helps to highlight biological signal in single-cell datasets.

The procedure to select variable features is implemented in the FindVariableFeatures function (the procedure models the mean-variance relationship inherent in single-cell data). By default, the function returns the 2,000 most variable features per dataset. These will be used in downstream analysis, like PCA.


```{r variable_features, warning=F, message=F}

pbmc <- FindVariableFeatures(pbmc, 
                             selection.method = "vst", 
                             nfeatures = 2000)

# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(pbmc), 10)

# plot variable features with labels
plot1 <- VariableFeaturePlot(pbmc)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
plot2

```


### Scaling the data

By scaling, Seurat applies a linear transformation to the expression levels of each gene, that is a standard pre-processing step prior to dimensional reduction techniques like PCA. 

The ScaleData function:

- Shifts the expression of each gene, so that the mean expression across cells is 0
- Scales the expression of each gene, so that the variance across cells is 1
(z-score transformation)

This step gives equal weight in downstream analyses, so that highly-expressed genes do not dominate

The results of this are stored in pbmc[["RNA"]]$scale.data

```{r scaling, warning=F, message=F}

all_genes <- rownames(pbmc) # perform scaling on all genes (by default, only the top 2000 are scaled)

pbmc <- ScaleData(pbmc, 
                  features = all_genes)

pbmc[["RNA"]]$scale.data[1:5,1:10]

```


### Linear dimensional reduction (PCA)

```{r pca_reduction, warning=F, message=F}

pbmc <- RunPCA(pbmc, 
               features = VariableFeatures(object = pbmc),
               verbose = T)

```

Seurat provides several ways of visualizing both cells and features that define the PCA, including VizDimReduction,  DimPlot, and DimHeatmap. PCA results are stored in pbmc[["pca"]]

```{r pca_loadings, warning=F, message=F}

VizDimLoadings(pbmc, dims = 1:2, reduction = "pca")

```

```{r, pca_scatter, warning=F, message=F}

DimPlot(pbmc, reduction = "pca")

```

DimHeatmap allows for easy exploration of the primary sources of heterogeneity in a dataset, and can be useful when trying to decide which PCs to include for further downstream analyses. Both cells and features are ordered according to their PCA scores. Setting "cells" to a number plots the 'extreme' cells on both ends of the spectrum, which dramatically speeds plotting for large datasets.

```{r pca_heatmap, warniheatmapng=F, message=F}

DimHeatmap(pbmc, dims = 1:2, 
           cells = 500, 
           balanced = TRUE)

```

### Determine the 'dimensionality' of the dataset

A heuristic method to decide the number of PC to consider generates an 'Elbow plot': a ranking of principle components based on the percentage of variance explained by each one (ElbowPlot function). In this example, we can observe an 'elbow' around PC9-10, suggesting that the majority of true signal is captured in the first 10 PCs.

```{r pca_elbow, warniheatmapng=F, message=F}

ElbowPlot(pbmc)

```


### Cluster the cells

Seurat applies a graph-based clustering approach. The distance metric which drives the clustering analysis is based on previously identified PCs. The approach to partioning the cellular distance matrix into clusters is the following: we embed cells in a graph structure - for example a K-nearest neighbor (KNN) graph, with edges drawn between cells with similar feature expression patterns, and then attempt to partition this graph into highly interconnected 'quasi-cliques' or 'communities'.
Seurat first constructs a KNN graph based on the euclidean distance in PCA space, and refine the edge weights between any two cells based on the shared overlap in their local neighborhoods (Jaccard similarity). This step is performed using the FindNeighbors function, and takes as input the previously defined dimensionality of the dataset (first 10 PCs).

To cluster the cells, we next apply modularity optimization techniques such as the Louvain algorithm (default) to iteratively group cells together, with the goal of optimizing the standard modularity function. The FindClusters function implements this procedure, and contains a resolution parameter that sets the 'granularity' of the downstream clustering, with increased values leading to a greater number of clusters. We find that setting this parameter between 0.4-1.2 typically returns good results for single-cell datasets of around 3K cells. Optimal resolution often increases for larger datasets.

The clusters can be found using the Idents function.

```{r clustering, warning=F, message=F}

pbmc <- FindNeighbors(pbmc, reduction = "pca", dims = 1:20)
pbmc <- FindClusters(pbmc, resolution = 0.5)

head(Idents(pbmc), 5)

```


### Run non-linear dimensional reduction for visualization (UMAP/tSNE)

Seurat offers several non-linear dimensional reduction techniques, such as tSNE and UMAP, to visualize and explore these datasets. The goal of these algorithms is to learn the underlying manifold of the data in order to place similar cells together in low-dimensional space. Cells within the graph-based clusters determined above should co-localize on these dimension reduction plots. As input to the UMAP and tSNE, we suggest using the same PCs as input to the clustering analysis.


#### Visualization with tSNE (t-Stochastic Neighbourhood Embedding)

t-SNE is a graph based, non-linear dimensionality reduction technique. 
It projects high dimensional data onto 2D or 3D components.

Pros
- t-SNE powerfully captures the non-linearity in high dimensional datasets and is able to retain the local structures in low dimensions. This is a huge improvement over PCA. t-SNE has been used as a gold standard method for scRNA-seq data visualisation.

Cons
- The way t-SNE works, it is impossible for it to preserve the global structure while performing dimension reduction. Only local structures are preserved, while the distances between groups are drastically different depending on the run.
- t-SNE embeds data points onto 2 or maximum 3 dimensions only.
- For huge datasets, the algorithm takes a long time to run.

```{r tsne, warning=F, message=F}

pbmc <- RunTSNE(pbmc, dims = 1:20)
DimPlot(pbmc, reduction = "tsne",label=T)

```

#### Visualization  with UMAP (Uniform Manifold Approximation and Projection)


UMAP is a dimension reduction technique that can be used for visualisation similarly to t-SNE, but also for general non-linear dimension reduction. 

UMAP is a relatively new dimensional reduction technique introduced by McInnes et al in 2018.
(McInnes, L, Healy, J, UMAP: Uniform Manifold Approximation and Projection for Dimension Reduction, ArXiv e-prints 1802.03426, 2018)

The algorithm is graph based and principally similar to t-SNE where it constructs a high dimensional graph representation of the data, then optimizes a low-dimensional graph to be as structurally similar as possible.

Pros
- Non linear datasets: UMAP is manifold learning dimension reduction technique and thus captures the non linearity of real world datasets. It is comparable to t-SNE in terms of data visualisation.
- The mathematical improvements in UMAP allow superior run time performance over t-SNE
- In comparison to t-SNE, UMAP offers better preservation of a data’s global structure. 
- Unlike t-SNE, UMAP has no computational restrictions on embedding dimensions and can be used as an effective pre-processing step to boost the performance of density based clustering algorithms.

Cons
- Lacks interpretability: Unlike PCA, where the principal components are directions of greatest variance of the source data, the lower dimension embeddings of UMAP lack strong interpretability.
- One of the core assumptions of UMAP is that there exists manifold structure in the data. Because of this, UMAP can tend to find manifold structure within the noise of a dataset. 

```{r umap, warning=F, message=F}

# If you haven't installed UMAP, you can do so via reticulate::py_install(packages ='umap-learn')

pbmc <- RunUMAP(pbmc, dims = 1:20)
DimPlot(pbmc, reduction = "umap",label=T )

```
### Finding differentially expressed features (cluster biomarkers)

Seurat can find markers that define clusters via differential expression. By default, setting only ident.1, it identifes positive and negative markers of a single cluster (specified in ident.1), compared to all other cells. FindAllMarkers automates this process for all clusters, but you can also test groups of clusters vs. each other, or against all cells.

The min.pct argument requires a feature to be detected at a minimum percentage in either of the two groups of cells, and the logfc.threshold argument requires a feature to be differentially expressed (on average) by some amount between the two groups. 

The default test used is the Wilcoxon Rank Sum test


#### Find all markers of cluster 0

```{r markers_0, warning=F, message=F}

c0_markers <- FindMarkers(pbmc, 
                          ident.1 = 0, 
                          min.pct = 0.25) #only test genes that are detected in a minimum fraction of min.pct cells in either of the two populations
head(c0_markers, n = 5)

```


The results data frame has the following columns :

p_val : p_val (unadjusted)

avg_log2FC : log fold-change of the average expression between the two groups. Positive values indicate that the feature is more highly expressed in the first group.

pct.1 : The percentage of cells where the feature is detected in the first group

pct.2 : The percentage of cells where the feature is detected in the second group

p_val_adj : Adjusted p-value, based on Bonferroni correction using all features in the dataset.


The following differential expression tests are currently supported:

“wilcox” : Wilcoxon rank sum test (default)

“bimod” : Likelihood-ratio test for single cell feature expression, (McDavid et al., Bioinformatics, 2013)

“roc” : Standard AUC classifier. For each gene, evaluates (using AUC) a classifier built on that gene alone, to classify between two groups of cells. An AUC value of 1 means that expression values for this gene alone can perfectly classify the two groupings (i.e. Each of the cells in cells.1 exhibit a higher level than each of the cells in cells.2). An AUC value of 0 also means there is perfect classification, but in the other direction. A value of 0.5 implies that the gene has no predictive power to classify the two groups. Returns a 'predictive power' (abs(AUC-0.5) * 2) ranked matrix of putative differentially expressed genes.

“t” : Student’s t-test

“poisson” : Likelihood ratio test assuming an underlying poisson distribution. Use only for UMI-based datasets

“negbinom” : Likelihood ratio test assuming an underlying negative binomial distribution. Use only for UMI-based datasets

“LR” : Uses a logistic regression framework to determine differentially expressed genes. Constructs a logistic regression model predicting group membership based on each feature individually and compares this to a null model with a likelihood ratio test.

“MAST” : Utilizes the MAST package to run the DE testing. GLM-framework that treates cellular detection rate as a covariate (Finak et al, Genome Biology, 2015) 


“DESeq2” : Identifies differentially expressed genes between two groups of cells based on a model using DESeq2 which uses a negative binomial distribution (Love et al, Genome Biology, 2014)


#### Find all markers distinguishing cluster 0 from clusters 1, 2 and 3

```{r markers_3, warning=F, message=F}

c3_markers <- FindMarkers(pbmc, 
                          ident.1 = 0, 
                          ident.2 = c(7,1,4), 
                          min.pct = 0.25)
head(c3_markers, n = 5)

```

#### Find markers for every cluster compared to all remaining cells, report only the positive ones

```{r all_markers, warning=F, message=F}

pbmc_markers <- FindAllMarkers(pbmc, 
                               only.pos = TRUE, 
                               min.pct = 0.25, 
                               logfc.threshold = 0.25)

pbmc_markers %>%
    group_by(cluster) %>%
    slice_max(n=2,order_by=avg_log2FC) 

```

### Visualization tools

Seurat offers several tools for visualizing marker expression. 

#### VlnPlot shows expression probability distributions across clusters

```{r vlnplot, warning=F, message=F}

VlnPlot(pbmc, features = c("1500015O10Rik", "Chac1"),pt.size=0)

```

#RidgePlot also shows expression probability distributions 

```{r ridgeplot, warning=F, message=F}

RidgePlot(pbmc, features = c("Spns3"))

```


# FeaturePlot visualizes feature expression on a tSNE, UMAP or PCA  plot

```{r featureplot, warning=F, message=F}

FeaturePlot(pbmc, features = c("1500015O10Rik", "Chac1"), order =T )


```

# DotPlot
Intuitive way of visualizing how feature expression changes across different identity classes (clusters). The size of the dot encodes the percentage of cells within a class, while the color encodes the AverageExpression level of cells within a class (blue is high).

```{r dotplot, warning=F, message=F}

DotPlot(pbmc, features = c("1500015O10Rik", "Chac1", "Spns3","Foxj1"))

```


#### DoHeatmap generates an expression heatmap for given cells and features. In this case, we are plotting the top 3 markers (or all markers if less than 3) for each cluster.

```{r geatmap, warning=F, message=F}

top3 <- pbmc_markers %>% group_by(cluster) %>% top_n(n = 3, wt = avg_log2FC)
DoHeatmap(pbmc, features = top3$gene) + NoLegend()

```

# Interactive plotting features 
Seurat utilizes R’s plotly graphing library to create interactive plots.
```{r}
plot <- FeaturePlot(pbmc, features = "1500015O10Rik")
HoverLocator(plot = plot, information = FetchData(pbmc, vars = c("ident", "nFeature_RNA")))
```

# Cell cycle analysis and regression in single cell RNA-Seq

A list of cell cycle markers for the S and G2/M phases,derived from Tirosh et al, 2015, is loaded with Seurat.  We can segregate this list into markers of G2/M phase and markers of S phase

```{r cell_cycle_marker_genes,warning=F,message=F}

s_genes <- cc.genes$s.genes
s_genes <- str_to_title(tolower(s_genes))

g2m_genes <- cc.genes$g2m.genes
g2m_genes <- str_to_title(tolower(g2m_genes))

s_genes
g2m_genes

```
# Assign Cell-Cycle Scores

First, each cell is assigned a score, based on its expression of G2/M and S phase markers. 
These marker sets should be anticorrelated in their expression levels, and cells expressing neither are likely not cycling and in G1 phase.

Scores are assigned in the CellCycleScoring function, which stores S and G2/M scores in object meta data, along with the predicted classification of each cell in either G2M, S or G1 phase. 
CellCycleScoring can also set the identity of the Seurat object to the cell-cycle phase by passing set.ident = TRUE (the original identities are stored as old.ident). 
Please note that Seurat does not use the discrete classifications (G2M/G1/S) in downstream cell cycle regression. Instead, it uses the quantitative scores for G2M and S phase. However, the predicted classifications are provided in case they are of interest.

```{r cell_cycle_scores,warning=F,message=F}

c_cycle <- CellCycleScoring(pbmc, s.features = s_genes, g2m.features = g2m_genes, set.ident = TRUE)
s_genes %in% rownames(c_cycle)
g2m_genes %in% rownames(c_cycle)
# view cell cycle scores and phase assignments
rownames(c_cycle)
head(c_cycle[[]])

```

### Visualize the distribution of cell cycle markers 

```{r ,warning=F,message=F}
RidgePlot(c_cycle, features = c("Mcm5"  ,   "Pcna"   ,  "Tyms"   ,  "Fen1"), ncol = 4)
```

Running a PCA on cell cycle genes confirms that cells separate entirely by phase

```{r ,warning=F,message=F}

c_cycle <- RunPCA(c_cycle, features = c(s_genes, g2m_genes),verbose=T)
DimPlot(c_cycle, reduction="pca")

```
# Regress out cell cycle scores during data scaling

We now attempt to subtract ('regress out') this source of heterogeneity from the data. For each gene, Seurat models the relationship between gene expression and the S and G2M cell cycle scores. The scaled residuals of this model represent a 'corrected' expression matrix, that can be used downstream for dimensional reduction.


After this regression,  a PCA on the variable genes no longer returns components associated with cell cycle
(long time step)

```{r}

c_cycle <- ScaleData(c_cycle, vars.to.regress = c("S.Score", "G2M.Score"), features = rownames(c_cycle))

c_cycle <- RunPCA(c_cycle, features = VariableFeatures(c_cycle), nfeatures.print = 10)
```

```{r}

c_cycle <- RunPCA(c_cycle, features = c(s_genes, g2m_genes))

DimPlot(c_cycle)

```

# SingleR (Aran et al. 2019)

SingleR can be considered a robust variant of nearest-neighbors classification, with some tweaks to improve resolution for closely related labels. 

Reference set: A comprehensive transcriptomic dataset (single-cell or bulk) of pure cell types, preferably with multiple samples per cell type.
Single-cell set: Single-cell RNA-seq dataset with unknown cell types

SingleR runs in two modes: 
(1) Single-cell: the annotation is performed for each single-cell independently. 
(2) Cluster: the annotation is performed on predefined clusters, where the expression of a cluster is the sum expression of all cells in the cluster

STEP 1:
Spearman coefficient is calculated for single-cell expression with each of the samples in the reference dataset. The correlation analysis is performed only on variable genes in the reference dataset

STEP 2:
Multiple correlation coefficients per cell types are aggregated to provide a single value per cell type per single-cell. 

step 3: 
In this step SingleR reruns the correlation analysis, but only for the top cell types from step 2. The analysis is performed only on variable genes between these cell types. The lowest value cell type is removed, and then this step is repeated until only two cell types remain. The cell type corresponding to the top value after the last run is assigned to the single-cell.

# Load the reference 

We will use one of the references created by the authors of SingleR.
```{r load_reference,warning=F,message=F}
# Loading Human Primary Cell Atlas dataset (Mabbott et al. 2013) as the reference 
library(xlsx)

read.xlsx("./data/Cell_marker_Mouse.xlsx", sheetIndex, header=TRUE, colClasses=NA)

```

We predict cell types using the SingleR() function. 

It is possible to use also a list of reference datasets. In this case only genes shared across the reference datasets will be used. 

If fine.tune = TRUE additional fine-tuning step is performed to improve resolution and remove low-quality labels. 
```{r cell_type_prediction,warning=F,message=F}

predictions <- SingleR(test=pbmc[["RNA"]]$data, #normalized counts of the unknown dataset
                        clusters = pbmc@meta.data$seurat_clusters, #vector of cluster identities for each cell 
                        ref=ref[["RNA"]]$data, #normalized counts of the reference dataset
                        labels = ref@meta.data$label.main,
                        fine.tune = TRUE) # performes steps to tune and improve the resolution 

#DataFrame  containing the annotation statistics for each cluster (one cluster per row). Delta.next = a numeric vector containing the difference between the best and next-best score
predictions

predictions_df<-data.frame(cluster=rownames(predictions),labels=predictions$labels)
```
plotScoreHeatmap() displays the correlation-based scores for all clusters across all reference labels. Each cluster is a column while each row is a label in the reference dataset. The final label for each cluster is shown in the top color bar. Similar scores for a group of labels indicates that the assignment is uncertain for those columns.

```{r scores_heatmap, warning=F, message=F, fig.width=8, fig.height=5}

plotScoreHeatmap(predictions)

```

Add cell types labels to the Seurat object
```{r cell_type_label, fig.width=6, fig.height=5}
pbmc[["SingleR_labels"]] <- predictions_df$labels[match(pbmc@meta.data$seurat_clusters, predictions_df$cluster)]

DimPlot(pbmc, group.by = "SingleR_labels")
```

# 2. Marker-based automatic annotation

Marker-based automatic annotation labels cells or cell clusters based on the characteristic expression of known marker genes. Set of marker genes can be obtained from databases (PanglaoDB, CellMarker, CellTypist ...) or manually from the literature.

To be successful, the marker gene or gene set (a collection of marker genes) should be specifically and consistently expressed in a given cell, cluster or class of cells. Marker-based automatic annotation works well once a relevant and sufficiently large set of marker genes is collected

# scType (Ianevski et al. 2022)

ScType accepts both positive and negative markers, i.e., gene that are not expected to be expressed in a particular cell type. Sctype provides its own marker database for human and mouse, obtained from the integration of the information available in the CellMarker database (http://biocc.hrbmu.edu.cn/CellMarker/) and PanglaoDB (https://panglaodb.se).
In total, the current version of the ScType database comprises 3,980 cell markers for 194 cell types in 17 human tissues and 4,212 cell markers for 194 cell types in 17 mouse tissues.

scType cell_type annotation: 
1. For each positive/negative marker compute specificity score, which indicate whether a gene is a marker for a specific cell types.
2. The raw expression matrix is normalized and Z-transform (scale the expression of each gene across cells)
3. The transformed matrix is multiply by the cell-type specificity score
4. For each cell types the expression scores of all its positive markers are summarized into a single enrichment score by summing them and dividing by square root of their number. The same is done for the negative markers.
5. The negative marker expression score is subtracted from the positive score to obtain the final enrichment score. Individual cells are assigned to a cell type based on the maximum value for the cell type marker set.


```{r load_library}
library("dplyr")
library("HGNChelper") #contains functions for identifying and correcting HGNC human gene symbols and MGI mouse gene symbols 
```

Prepare marker genes to use for the annotation. By default, scType use the in-built cell marker DB, however, any marker genes data can be used.
```{r marker_db, warning=FALSE}
# DB file
db_ <- "https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/ScTypeDB_full.xlsx";
tissue <- "Immune system" # e.g. Immune system,Pancreas,Liver,Eye,Kidney,Brain,Lung,Adrenal,Heart,Intestine,Muscle,Placenta,Spleen,Stomach,Thymus 

# load gene set preparation function
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/gene_sets_prepare.R")
# prepare gene sets
gs_list <- gene_sets_prepare(db_, tissue)
gs_list[["gs_positive"]][5:8] #positive markers
gs_list[["gs_negative"]][5:8] #negative markers

```

```{r}
# load cell type annotation function
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/sctype_score_.R")

es.max <- sctype_score(scRNAseqData = pbmc[["RNA"]]$scale.data, scaled = TRUE, gs = gs_list$gs_positive, gs2 = gs_list$gs_negative) # in case there are no negative markers just set gs2 = NULL

# merge by cluster
cL_resutls <- do.call("rbind", lapply(unique(pbmc@meta.data$seurat_clusters), function(cl){
    es.max.cl = sort(rowSums(es.max[ ,rownames(pbmc@meta.data[pbmc@meta.data$seurat_clusters==cl, ])]), decreasing = !0)
    head(data.frame(cluster = cl, type = names(es.max.cl), scores = es.max.cl, ncells = sum(pbmc@meta.data$seurat_clusters==cl)), 10)
}))
sctype_scores <- cL_resutls %>% group_by(cluster) %>% top_n(n = 1, wt = scores)  

# set low-confident (low ScType score) clusters to "unknown"
sctype_scores$type[as.numeric(as.character(sctype_scores$scores)) < sctype_scores$ncells/4] <- "Unknown"
print(sctype_scores[,1:3])
```
Assign cell types to each cluster
```{r}
pbmc[["scType_labels"]] <- sctype_scores$type[match(pbmc@meta.data$seurat_clusters, sctype_scores$cluster)]

DimPlot(pbmc, reduction = "umap", label = TRUE, repel = TRUE, group.by = 'scType_labels')        

```
Wrapper function 
```{r wrapper_function, warning=F}
# get cell-type by cell matrix
source("https://raw.githubusercontent.com/kris-nader/sc-type/master/R/sctype_wrapper.R")

pbmc <- run_sctype(pbmc,known_tissue_type="Immune system",custom_marker_file ="https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/ScTypeDB_full.xlsx",name="scType_labels",plot=TRUE)
```


```{r annotation_comparison, fig.width=10, fig.height=3}
plot1 <- DimPlot(pbmc, reduction = "umap", group.by = 'SingleR_labels')  
plot2 <- DimPlot(pbmc, reduction = "umap", group.by = 'scType_labels')        
plot1+plot2
```



```{r}

```

```{r}

```




















































